/*
* 
* Toy file for testing my Lox interpreter.
* This file is only as close to "valid Lox" as is useful for my current testing needs--no promises it'll always be fully valid.
* 
*/

// fun foo(a) {
//     a = "Lox is a useful language?"; // it isn't, but it's useful for learning!
//     print a;
// }

// print "one";
// print true;
// print 2 + 1;


// personally, I expected this to print 3, which it does
// but I think that's because I thought through how the interpreter would see it
// I tested this in Node, which considers this an access before initialization error
// which is really interesting to me.  it implies Node has a two-step variable definition process:
// declaration, which must be called while interpreting the l-value
// then assignment, which is called while interpreting the initializer expression
// var a = 1;
// {
//   var a = a + 2;
//   print a;
// }

// var count = 3;
// while (count > 0) {
    // print count;
    // count = count - 1;
// }
// print "Boom!";

// var a = 0;
// var temp;

// for (var b = 1; a < 10000; b = temp + b) {
    // print a;
    // temp = a;
    // a = b;
// }

// 
// if (a == 1) {
//     print "One";
// } else if (a == 2) {
//     print "Two";
// } else if (a == 3) {
//     print "Three";
// } else print "Something else.";
// 
// if (a == 5) print "Check check.";

// fun fibCountdown() {
//     var a = 1;
//     var last = 0;
//     var b = '';
//     for (; a != 13 ;) { // unlucky!
//         var tmp = a;
//         a = a + last;
//         last = tmp;
// 
//         print a;
//         var a = a;
//         var b = b;
//         while (a > 0) {
//             b = b + a--;
//         }
//         print b;
//     }
// }

// fibCountdown();

// fun sayHi(first, last) {
//     print "Hi, " + first + " " + last + "!";
// }

// sayHi("Dear", "Reader");

// fun fib(n) {
//     if (n <= 1) return n;
//     return fib(n - 2) + fib(n - 1);
// }

// for (var i = 0; i < 20; i ++) {
//     print (fib(i));
// }

// fun makeCounter() {
//     var i = 0;
//     fun count() {
//         print ++i;
//     }
// 
//     return count;
// }
// 
// var counter = makeCounter();
// counter();
// counter();
// 
// fun scope(a) {
//     var a = "local";
//     print a;
// }
// 
// scope(1);

// fun thrice(fn) {
//     for (var i = 1; i <=3; i++) {
//         fn(i);
//     }
// }
// 
// thrice(fun (a) {
//     print a;
// });
// 
// var triple = fun(i) {
//     return 3 * i;
// };
// 
// print triple(3);

// (fun () {print 'foo';})();

// fun foo() {
//     print 'first foo';
// }

// fun bar() {
//     bar = foo;
//     bar();
// }

// var bar = fun(count) {
//     var foo = "woo";
//     print count--;
//     if (count > 0)
//         bar(count);
// };

class Thing {
  getCallback() {
    fun localFunction() {
      print this;
    }

    return localFunction;
  }
}

var callback = Thing().getCallback();
callback();

class Cake {
  init() {
    flavor = "Black Forest";
  }
  taste() {
    var adjective = "delicious";
    print "The " + this.flavor + " cake is " + adjective + "!";
  }
}

var cake = Cake();
// cake.flavor = "German chocolate";
cake.taste(); // Prints "The German chocolate cake is delicious!".
